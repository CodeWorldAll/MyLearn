# 哲学
## 文化
    禅
## Unix的生命力
## 反对学习Unix文化的理由
## Unix之失
## Unix之得
### 开源软件
### 跨平台可移植性和开放标准
### Internet和万维网
    Tcp and IP bake off （TCP/IP 不同实现大比拼）
### 开源社区
### 从头到脚的灵活性
### Unix Hack 之趣
### Unix的经验别处也可适用

## Unix哲学基础
- 原则1: 你无法断定程序会再什么地方耗费运行时间，瓶颈经常出现在想不到的地方，所以别着急胡乱找个地方改代码，除非你已经证实那儿就是瓶颈所在
- 原则2：估量，在你对没代码进行估量，特别是没找到最好是的那部分之前，别去优化速度
- 原则3：花哨的算法在n很小时通常很慢，而n通常很小，花哨算法的常数复杂度很大，除非你确定n总是很大，否则不要用花哨算法（即使n很大，也优先考虑原则2）
- 原则4：花哨的算法比简单算法更容易出bug，更难实现，尽量使用简单的算法配合简单的数据结构
- 原则5：数据压倒一切，如果已经选择了正确的数据结构并且把一切都组织的井井有条，准确的算法也就不言自明，编程的核心是数据结构，而不是算法
### 概括
- 模块原则
    - 使用简洁的接口拼合简单的组件
- 清晰原则
    - 清晰胜于机巧
- 组合原则
    - 设计师考虑拼接组合
- 分离原则
    - 策略同机制分离，接口与引擎分离
- 简洁原则
    - 设计要简洁，复杂度能低则低
- 吝啬原则
    - 除非确定无它法，不要编写庞大的程序
- 透明性原则
    - 设计要可见，一边审查和调试
- 健壮原则
    - 健壮源于透明与简洁
- 表示原则
    - 把知识叠入数据以求逻辑质朴而健壮
- 通俗原则
    - 接口设计避免标新立异
- 缄默原则
    - 如果一个程序没有什么好说的，就沉默
- 补救原则
    - 出现异常时，马上退出并给出足够错误信息
- 经济原则
    - 宁花机器一分，不花程序员一秒
- 生成原则
    - 避免手工hack，尽量避免程序去生成程序
    

    